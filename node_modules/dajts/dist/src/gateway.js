/** @format */
'use strict';
//
import User from './models/user.js';
import Token from './models/token.js';
//
import { errors } from './errors.js';
import readFile from './readFile.js';
import readFileSync from './readFileSync.js';
import writeFile from './writeFile.js';
import writeFileSync from './writeFileSync.js';
import { createFile, createFileSync } from './createFile.js';
//
//
export default class Daj {
    //
    verify() {
        console.log('verificado');
    }
    //
    //method get class name
    //
    getCN(obj) {
        return Reflect.get(obj, 'constructor').name;
    }
    //
    //method get property
    //
    //private getPro(obj: any, pro: string) {return Reflect.get(obj as object, pro); }
    //
    //method get property class name
    //
    getProCN(data, _object) {
        return Reflect.get(data, this.getCN(_object));
    }
    //
    //method getAll
    //
    getAll(callback) {
        readFile(callback);
    }
    //
    //method getall async
    //
    getAllSync() {
        return readFileSync();
    }
    //
    //method checkIsArray
    //
    checkIsArray(obj) {
        const constructor_name = this.getCN(obj);
        let objIsArray = false;
        Reflect.deleteProperty(obj, 'constructor');
        if (constructor_name === 'Array') {
            for (const key in obj) {
                if (Reflect.ownKeys(Reflect.get(obj, key))[0] === 'constructor') {
                    objIsArray = true;
                    break;
                }
            }
        }
        return objIsArray;
    }
    //
    //method register
    //
    registerSync(obj) {
        const { error, data: users } = this.getSync(User.getInstance());
        if (!error) {
            let usersExist = [];
            if (users)
                usersExist = users.filter((u) => u.user === obj.user);
            if (usersExist.length === 1)
                return { error: errors.userNotExist('gateway', 77), data: null };
            return this.postSync(obj);
        }
        else {
            return this.postSync(obj);
        }
        return { error, data: null };
    }
    //
    //method check extende type
    //
    CheckExtendsType(obj) {
        const extendsObject = Object.getPrototypeOf(Object.getPrototypeOf(obj)).constructor.name;
        if (extendsObject === 'User')
            return extendsObject;
        return this.getCN(obj);
    }
    //
    //method login
    //
    loginSync(credential) {
        const user = User.getInstance();
        const { error, data: users } = this.getSync(user);
        if (!error && users) {
            const userExist = users.filter((u) => u.user === credential.user && u.password === credential.password);
            if (userExist.length === 1) {
                Reflect.set(userExist[0], '_token', new Token());
                user.mapper(userExist[0]);
                const { error /*, data*/ } = this.putSync(user);
                if (error)
                    return Token.empty();
                return user.token;
            }
        }
        return Token.empty();
    }
    //
    //method checkToken
    //
    checkTokenSync(token) {
        const { error, data: users } = this.getSync(User.getInstance());
        if (error && !users)
            return false;
        const useExist = users.filter((u) => {
            var _a;
            const newUser = User.getInstance();
            newUser.mapper(u);
            if (((_a = newUser === null || newUser === void 0 ? void 0 : newUser.token) === null || _a === void 0 ? void 0 : _a.token) === token.token)
                return true;
        });
        if (useExist.length === 1)
            return true;
        return false;
    }
    //
    //method logout
    //
    logoutAsync(credential) {
        const user = User.getInstance();
        const { error, data: users } = this.getSync(user);
        if (!error && users) {
            const useExist = users.filter((u) => u.user === credential.user);
            if (useExist.length === 1) {
                Reflect.set(useExist[0], 'token', null);
                user.mapper(useExist[0]);
                const { error /*, data */ } = this.putSync(user);
                if (error)
                    return false;
                return true;
            }
        }
        return false;
    }
    //
    //method get
    //
    get(callback, obj) {
        readFile((error, data) => {
            if (!error) {
                callback(null, this.getProCN(data, obj));
            }
            else {
                callback(error, null);
            }
        });
    }
    //
    //method get async
    //
    getSync(obj) {
        const { error, data } = readFileSync();
        if (!error)
            return {
                error: null,
                data: this.getProCN(data, obj),
            };
        return { error, data: null };
    }
    //
    //method get by key
    //
    getByKey(callback, obj, key) {
        readFile((error, data) => {
            if (!error) {
                const objects = this.getProCN(data, obj);
                let isnotfound = true;
                for (let props in objects) {
                    const _obj_ = Reflect.get(objects, props);
                    if (Reflect.get(_obj_, 'key') === key) {
                        callback(null, Reflect.get(objects, props));
                        isnotfound = false;
                        break;
                    }
                }
                if (isnotfound)
                    callback(errors.keyNotFound('gateway', 196), null);
            }
            else {
                //console.error(errors.notData("gateway",197));
                callback(errors.notData('gateway', 199), null);
            }
        });
    }
    //
    //method getkey async
    //
    getByKeySync(obj, key) {
        const { error, data } = readFileSync();
        if (!error) {
            const value = this.getProCN(data, obj);
            for (let props in value) {
                const _obj_ = Reflect.get(value, props);
                if (Reflect.get(_obj_, 'key') === key) {
                    return { error: null, data: _obj_ };
                    break;
                }
            }
            return { error: errors.notData('gateway', 219), data: null };
        }
        else {
            return { error, data: null };
        }
    }
    //
    //method post
    //
    post(callback, obj) {
        const objIsArray = this.checkIsArray(obj);
        const constructor_name = this.CheckExtendsType(obj);
        createFile((error, data) => {
            let allData = data === null || typeof data === 'object' ? data : {};
            function setAllData(objData, isNewProtype = false) {
                const aux = [];
                const auxAllData = {};
                if (isNewProtype)
                    aux.push(objData);
                try {
                    !Reflect.set(isNewProtype ? auxAllData : allData, constructor_name, isNewProtype ? aux : objData);
                    if (isNewProtype)
                        allData = auxAllData;
                }
                catch (err) {
                    callback(errors.notAdd('gateway', 244), null);
                    return false;
                }
                return true;
            }
            let isError = false;
            if (error === null) {
                if (allData !== null) {
                    const specificObj = Reflect.get(allData, constructor_name);
                    if (specificObj !== undefined) {
                        if (objIsArray && Array.isArray(obj)) {
                            specificObj.push(...obj);
                        }
                        else {
                            specificObj.push(obj);
                        }
                        isError = !setAllData(specificObj);
                    }
                    else {
                        isError = !setAllData(obj);
                    }
                }
                else {
                    isError = !setAllData(obj, true);
                }
            }
            else {
                callback(error, null);
                isError = true;
            }
            if (!isError) {
                if (allData === undefined) {
                    callback(errors.notData('gateway', 279), null);
                    isError = true;
                }
                if (!isError) {
                    writeFile(allData, (error, _) => {
                        if (error) {
                            //console.log(error);
                            callback(errors.notDataAccess('gateway', 287), null);
                            isError = true;
                        }
                        if (!isError)
                            callback(null, 'Success');
                    });
                }
            }
        }, this);
    }
    //
    //method post async
    //
    postSync(obj) {
        const objIsArray = this.checkIsArray(obj);
        const constructor_name = this.CheckExtendsType(obj);
        const { error, data } = createFileSync(this);
        let allData = data === null || typeof data === 'object' ? data : {};
        if (error !== null)
            return { error: error, data: null };
        function setAllData(objData, isNewProtype = false) {
            const aux = [];
            const auxAllData = {};
            if (isNewProtype)
                aux.push(objData);
            try {
                !Reflect.set(isNewProtype ? auxAllData : allData, constructor_name, isNewProtype ? aux : objData);
                if (isNewProtype)
                    allData = auxAllData;
            }
            catch (err) {
                // console.log(err);
                //Todo este valor de retorno, se esta tomado en cuenta
                return { error: errors.notAdd('gateway', 323), data: null };
            }
            return { error: null, data: null };
        }
        if (allData !== null) {
            let specificObj = Reflect.get(allData, constructor_name);
            if (specificObj !== undefined) {
                if (objIsArray && Array.isArray(obj)) {
                    specificObj.push(...obj);
                }
                else {
                    specificObj.push(obj);
                }
                const { error } = setAllData(specificObj);
                if (error)
                    return { error, data: null };
            }
            else {
                const { error } = setAllData(obj);
                if (error)
                    return { error, data: null };
            }
        }
        else {
            const { error } = setAllData(obj, true);
            if (error)
                return { error, data: null };
        }
        //Todo muy poco probable que sedé esta condición
        if (allData === null) {
            return { error: errors.notData('gateway', 351), data: null };
        }
        const { error: wfsError, data: wfsData } = writeFileSync(allData);
        if (!wfsError) {
            return {
                error: null,
                data: wfsData,
            };
        }
        else {
            //console.log(error);
            return { error: errors.notData('gateway', 363), data: null };
        }
    }
    //
    //method put
    //
    put(callback, obj) {
        const objIsArray = this.checkIsArray(obj);
        const constructor_name = this.CheckExtendsType(obj);
        if (objIsArray) {
            callback(errors.arrayNot('gateway', 373), null);
        }
        else {
            Reflect.deleteProperty(obj, 'constructor');
            const replaceEleOfArray = (objToReplace) => {
                for (const e in objToReplace) {
                    if (Reflect.get(objToReplace, e).key == Reflect.get(obj, 'key')) {
                        Reflect.set(objToReplace, e, obj);
                        break;
                    }
                }
            };
            this.getAll((error, allData) => {
                if (error) {
                    console.log(error);
                }
                function setAllData(objData) {
                    if (!Reflect.set(allData, constructor_name, objData)) {
                        callback(errors.notAdd('gateway', 389), null);
                        return true;
                    }
                    return false;
                }
                let isError = false;
                if (allData !== null) {
                    let specificObj = Reflect.get(allData, constructor_name);
                    if (specificObj !== undefined) {
                        replaceEleOfArray(specificObj);
                        isError = setAllData(specificObj);
                    }
                    else {
                        callback(errors.notData('gateway', 404), null);
                        isError = true;
                    }
                }
                else {
                    callback(errors.notData('gateway', 408), null);
                    isError = true;
                }
                if (!isError) {
                    if (allData === undefined) {
                        callback(errors.notData('gateway', 414), null);
                        isError = true;
                    }
                    if (!isError) {
                        writeFile(allData, callback);
                    }
                }
            });
        }
    }
    //
    //method put async
    //
    putSync(obj) {
        const objIsArray = this.checkIsArray(obj);
        const constructor_name = this.CheckExtendsType(obj);
        if (objIsArray) {
            return { error: errors.arrayNot('gateway', 432), data: null };
        }
        function replaceEleOfArray(objToReplace) {
            for (const key in objToReplace) {
                if (Reflect.get(objToReplace, key).key == Reflect.get(obj, 'key')) {
                    Reflect.set(objToReplace, key, obj);
                    break;
                }
            }
        }
        const { error, data: allData } = this.getAllSync();
        if (error !== null)
            return { error, data: null };
        function setAllData(objData) {
            if (!Reflect.set(allData, constructor_name, objData)) {
                return { error: errors.notAdd('gateway', 452), data: null };
            }
        }
        if (allData !== null) {
            let specificObj = Reflect.get(allData, constructor_name);
            if (specificObj !== undefined) {
                replaceEleOfArray(specificObj);
                setAllData(specificObj);
            }
            else {
                return { error: errors.notData('gateway', 463), data: null };
            }
        }
        else {
            return { error: errors.notData('gateway', 466), data: null };
        }
        if (allData === undefined) {
            return { error: errors.notData('gateway', 470), data: null };
        }
        const { error: _error, data } = writeFileSync(allData);
        if (!_error)
            return { error: null, data };
        return { error: errors.notDataAccess('gateway', 477), data };
    }
    //
    //method delete
    //
    delete(callback, obj) {
        let constructor_name = this.getCN(obj);
        Reflect.deleteProperty(obj, 'constructor');
        this.getAll((error, allData) => {
            if (error) {
                console.log(error);
            }
            function setAllData(objData) {
                if (!Reflect.set(allData, constructor_name, objData)) {
                    callback(errors.notAdd('gateway', 489), null);
                    return true;
                }
                return false;
            }
            let isError = false;
            if (allData !== null) {
                let specificObj = Reflect.get(allData, constructor_name);
                if (specificObj !== undefined) {
                    const index = specificObj.findIndex((e) => Reflect.get(e, 'key') === Reflect.get(obj, 'key'));
                    if (index > -1) {
                        specificObj.splice(index, 1);
                    }
                    isError = setAllData(specificObj);
                }
                else {
                    callback(errors.notData('gateway', 511), null);
                    isError = true;
                }
                if (!isError) {
                    writeFile(allData, (error, _) => {
                        if (error) {
                            //console.log(error);
                            callback(errors.notDataAccess('gateway', 519), null);
                            isError = true;
                        }
                        if (!isError)
                            callback(null, 'Success');
                    });
                }
            }
            else {
                callback(errors.notData('gateway', 526), null);
            }
        });
    }
    //
    //method  delete async
    //
    deleteSync(obj) {
        let constructor_name = this.getCN(obj);
        Reflect.deleteProperty(obj, 'constructor');
        const { error, data: allData } = this.getAllSync();
        if (error !== null)
            return { error, data: null };
        function setAllData(objData) {
            if (!Reflect.set(allData, constructor_name, objData)) {
                return { error: errors.notAdd('gateway', 544), data: null };
            }
            return { error: null, data: null };
        }
        if (allData !== null) {
            let specificObj = Reflect.get(allData, constructor_name);
            if (specificObj !== undefined) {
                const index = specificObj.findIndex((e) => Reflect.get(e, 'key') === Reflect.get(obj, 'key'));
                if (index > -1) {
                    specificObj.splice(index, 1);
                }
                setAllData(specificObj);
            }
            else {
                return { error: errors.notData('gateway', 563), data: null };
            }
            const { error } = writeFileSync(allData);
            if (error)
                return { error, data: null };
            return { error, data: 'Success' };
        }
        else {
            return { error: errors.notData('gateway', 572), data: null };
        }
    }
}
